# 解决数据隔离与持久化问题的实施计划

您的问题非常关键：目前您看到“旧数据”是因为系统仍在使用浏览器本地存储 (`localStorage`)，它是跟浏览器绑定的，而不是跟登录用户绑定的。要实现真正的“多用户数据隔离”和“云端同步”，我们需要将数据存储逻辑从本地迁移到数据库，并严格按照 `userId` 进行读写。

## 1. 核心问题分析
*   **现象**：登录不同账号看到相同数据。
*   **原因**：`ConversationService` 目前仍在使用 `localStorage`（本地缓存），没有真正调用后端数据库 API。
*   **解决方案**：
    1.  在数据库中创建 `Conversation` 表来存储所有对话历史。
    2.  创建后端 API 接口，所有增删改查操作都强制校验当前登录的 `userId`。
    3.  重构前端 `ConversationService`，改为调用这些 API。

## 2. 实施步骤

### 第一步：数据库模型升级 (Prisma Schema)
我们需要在数据库中正式建立“对话”模型，并将其与用户绑定。

```prisma
model Conversation {
  id            String   @id @default(cuid())
  userId        String   // 核心：绑定到特定用户
  title         String
  type          String   // 'learning' | 'general'
  messages      Json     // 存储聊天记录数组
  
  // 元数据
  lastActivity  DateTime @default(now())
  isArchived    Boolean  @default(false)
  
  // 学习相关字段
  subject       String?
  topic         String?
  
  // 关联
  learningSession LearningSession? // 关联到具体的学习会话
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId]) // 加索引，确保查询速度快
  @@map("conversations")
}
```

### 第二步：创建后端 API (中文提示)
创建以下 API 路由，确保所有返回信息均为**中文**：
*   `GET /api/conversations`：获取当前用户的对话列表。
*   `POST /api/conversations`：创建新对话。
*   `PUT /api/conversations/[id]`：更新对话（追加消息、修改标题）。
*   `DELETE /api/conversations/[id]`：删除对话。

**安全机制**：每个 API 都会使用 `auth()` 获取 `userId`，如果未登录直接返回 "未授权"。查询时强制 `where: { userId: currentUserId }`，确保用户只能看到自己的数据。

### 第三步：前端服务重构
修改 `app/services/conversationService.ts`：
*   **废弃**：删除所有 `localStorage` 相关代码。
*   **接入**：替换为 `fetch('/api/conversations', ...)` 调用。

## 3. 预期效果
1.  **数据隔离**：张三登录只能看到张三的对话，李四登录只能看到李四的。
2.  **云端同步**：您在电脑 A 上聊的天，去电脑 B 登录账号也能看到。
3.  **中文反馈**：接口报错或提示将全部显示为中文（如“获取对话列表失败”、“未授权的操作”）。

我们将立即开始执行此计划。
